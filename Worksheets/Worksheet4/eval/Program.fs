// Learn more about F# at http://fsharp.org

module Program

open System
open EEExtensions
open Tokenize
open Parse
open BracketAbstract
open Reduce
open Expecto.ExpectoFsCheck
open Expecto

//-----------------------------------------------------------------
// Tests written as Expecto Test values, each tagged with [<Tests>]
//




[<Tests>]
let t1 = // test without HOF
    let makeTokenTest name inp outp =
        testCase name <| fun () ->
        let toks = tokenize inp
        Expect.equal toks outp (sprintf "Tokenize '%s'" inp)
    Expecto.Tests.testList "Tokenizer Tests"
            [
                makeTokenTest "Token2" "" [END]
                makeTokenTest "Token1" "x" [SYM ("x",0);END]
                makeTokenTest "Token3" @"\x.()" [LAMBDA 0 ; SYM("x",1); DOT 2; LBRA 3; RBRA 4; END]
            ]
            

[<Tests>]
let t2 = // test without HOF
    let makeParserTest name inp outp =
        testCase name <| fun () ->
            let toks = tokenize inp
            let ast = parse toks
            Expect.equal ast outp (sprintf "Parse '%s'" inp)
    Expecto.Tests.testList "Parser tests"
        [
            makeParserTest "Parse1" "f g h" (Apply(Apply(Var "f",Var "g"),Var "h"))
        ]

[<Tests>]
let t3 = // test without HOF
    let makeBATest name inp outp =
        testCase name <| fun () ->
            let toks = tokenize inp
            let ast = parse toks
            let ba = removeLambdas ast
            Expect.equal ba outp (sprintf "Bracket Abstract '%s'" inp)
    Expecto.Tests.testList "Parser tests"
        [
            makeBATest "BA1" "f g h" (Apply3 (Var "f") (Var "g") (Var "h"))
            makeBATest "BA2" @"\x.x" (Comb "I")
            makeBATest "BA3" @"\x.y" (Apply2 (Comb "K") (Var "y"))
            makeBATest "BA4" @"\x.x x" (Apply3 (Comb "S") (Comb "I") (Comb "I"))
        ]

[<Tests>]
let t4 = // test without HOF
    let makeReduceTest name inp outp =
        testCase name <| fun () ->
            let toks = tokenize inp
            let ast = parse toks
            let ba = removeLambdas ast
            let red = reduce 1000 ba []
            Expect.equal red outp (sprintf "Reduce '%s'" inp)
    Expecto.Tests.testList "Reduce tests"
        [
            makeReduceTest "Reduce1" "S f g x" (Reduced(Var "f", [(Var "x") ; (Apply2 (Var "g")(Var "x"))]))
        ]



let T = tokenize
let TP = tokenize >> parse
let TPB = tokenize >> parse >> removeLambdas
let TPB' = tokenize >> parse' >> Result.map removeLambdas

let reduce' maxStep inp = 
    reduce maxStep inp []

/// Convert lambda expression string into combinator & list of args form
/// wrapped in Reduced: as generated by reduce
let TPBmap txt =
    let rec TPBmap' argL = function
        | Apply(f, arg)  -> TPBmap' (arg :: argL) f
        | co -> Reduced(co, argL)
    TPBmap' [] (TPB txt)


    


[<EntryPoint>]
let rec main argv =
    Tests.runTestsInAssembly Tests.defaultConfig [||] |> ignore
    Console.ReadKey() |> ignore
    0 // return an integer exit code


